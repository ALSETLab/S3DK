<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Stronggrid_Method · Documentation</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="# Strongrid IEEE C37.118 DLL"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Stronggrid_Method · Documentation"/><meta property="og:type" content="website"/><meta property="og:url" content="https://ALSET.github.io/S3DK/index.html"/><meta property="og:description" content="# Strongrid IEEE C37.118 DLL"/><meta property="og:image" content="https://ALSET.github.io/S3DK/img/ALSET_RPI.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://ALSET.github.io/S3DK/img/docusaurus.png"/><link rel="shortcut icon" href="/S3DK/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/S3DK/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/S3DK/"><img class="logo" src="/S3DK/img/ALSET_RPI.png" alt="Documentation"/><h2 class="headerTitleWithLogo">Documentation</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/S3DK/docs/S3DK_Utilities_VI_Overview.html" target="_self">Documentation</a></li><li class=""><a href="/S3DK/docs/PDC_Reader.html" target="_self">Integrated Examples</a></li><li class=""><a href="/S3DK/en/help.html" target="_self">Help</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Stronggrid_Method</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="strongrid-ieee-c37118-dll"></a><a href="#strongrid-ieee-c37118-dll" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Strongrid IEEE C37.118 DLL</h1>
<h1><a class="anchor" aria-hidden="true" id="dll-interface-description"></a><a href="#dll-interface-description" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DLL Interface Description</h1>
<h2><a class="anchor" aria-hidden="true" id="introduction"></a><a href="#introduction" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>INTRODUCTION</h2>
<h3><a class="anchor" aria-hidden="true" id="document-scope"></a><a href="#document-scope" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Document scope</h3>
<p>This document gives the Strongrid DLL users an overview of methods and information the DLL interface is capable of providing. It also suggests different threading models that can be implemented by the client application to efficiently use the information these methods provide.</p>
<h3><a class="anchor" aria-hidden="true" id="strongrid-ieee-c37118-dll-interface-overview"></a><a href="#strongrid-ieee-c37118-dll-interface-overview" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Strongrid IEEE C37.118 DLL Interface overview</h3>
<p><img src="/docs/img/STRONgrid-DLL-Architecture.png" alt="DLL Architecture"></p>
<p>The Strongrid IEEE C37.118 DLL interface connects the client application to the PMUs/PDCs through the IEEE C37.118 protocol.  In first version of the Strongrid DLL  only the DLL API interface is implemented, while the other interfaces are prepared in the code.</p>
<p>The complete information it is possible to retrieve through the Strongrid DLL API interface is  given in the Appendix 1.</p>
<h3><a class="anchor" aria-hidden="true" id="usage-of-methods"></a><a href="#usage-of-methods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage of methods</h3>
<p>The usage of these methods depends on the clients requirements, i.e. the client application can either call methods with required fields or it shall call methods that will retrieve all the information, the  flow charts below gives an overview of using these methods differently in different ways based on threading models being adopted.</p>
<p>The Strongrid DLL Threading model shall support 2 different modes, giving the user a choice between ease of use and scalability.</p>
<p>The threading model is critical for developing a scalable system, however, it may come at the cost of some additional complexity. The stronggrid DLL shall support the following two modes:</p>
<ul>
<li>One thread per PMU/PDC</li>
<li>Threadpool w/ readqueue</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="one-thread-per-pmu-pdc"></a><a href="#one-thread-per-pmu-pdc" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>One thread per PMU/PDC</h3>
<p>This mode will be the simplest to implement for the client – Each individual PMU can be used synchronously and in isolation within each thread. Reading from the PMU will be synchronous, and the user will not have to deal with synchronization and coordination of threads. As shown in the flow chart 1 (Appendix 2).</p>
<p>As a general rule of thumb, one should expect at least 1 MB of memory per thread and increased latency for each thread. The amount of threads a system can sustain is very system dependent andcannot be accurately predicted, however, the number of threads should never exceed approximately 100 on any system.</p>
<h3><a class="anchor" aria-hidden="true" id="threadpool-with-readqueue"></a><a href="#threadpool-with-readqueue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Threadpool with readqueue</h3>
<p>The readqueue contains a list of PMU/PDC's which have data waiting to be read. This makes it possible to call &quot;readFrame&quot; without any significant blocking behavior, making it possible to use a threadpool to act as &quot;workers&quot; in reading the data from the network and decoding it. Flow chart 2 (Appendix 2) displays this model of threading.</p>
<p><strong>The flow of the program becomes:</strong></p>
<ol>
<li>1)Read list of PMU/PDC's with data available to be read: 'readPendingQueue'*</li>
<li>2)Delegate the content of the list to the threadpool which in turn calls 'readFrame' for each PDC/PMU in the list</li>
<li>Any calls to the &quot;getter&quot; functions should immediately follow &quot;readFrame&quot; within each thread.</li>
<li>3)Wait for all threads to complete</li>
<li>Failure to wait will result in the same PMU/PDC's being returned on the next call to 'readPendingQueue' making coordination that much harder.</li>
<li>4)Go to (1)</li>
</ol>
<p><strong>readPendingQueue* is not yet defined in the DLL interface</strong></p>
<p>The size of the threadpool should vary with the system – ie. [1,4] threads per CPU core should yield the best results.</p>
<h3><a class="anchor" aria-hidden="true" id="conclusions"></a><a href="#conclusions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusions</h3>
<p>The &quot;Theadpool with readqueue&quot; approach should under no circumstances be slower than the &quot;one thread per PMU/PDC&quot; approach, and is significantly more scalable. The increased complexity however, means the user must make a conscious decision based on the scope and scale of the project, balancing complexity with scalability and latency requirements.</p>
<h2><a class="anchor" aria-hidden="true" id="strongrid-ieee-c37118-dll-apis"></a><a href="#strongrid-ieee-c37118-dll-apis" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Strongrid IEEE C37.118 DLL APIs</h2>
<h3><a class="anchor" aria-hidden="true" id="general-functions"></a><a href="#general-functions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>General functions</h3>
<table>
<thead>
<tr><th><strong>Method</strong></th><th><strong>Description</strong></th></tr>
</thead>
<tbody>
<tr><td>int   <strong>connectPdc</strong> (char *ipAddress, char *port, int32_t pdcId, int32_t * pseudoPdcId )</td><td>The connectPdc API will create an object of StrongridIEEEC37118Client and adds it to the vector/map that is maintained globally and will attempt to establish a socket connection using the credentials passed as arguments,On success this API will return 0, and a &quot;pseudoPdcId&quot;, uniquely identifying the PDC.On failure this API will free the created StrongridIEEEC37118Client object and return 1</td></tr>
<tr><td>int   <strong>readHeaderData</strong> ( int32_t timeOutMs int32_t pseudoPdcId)</td><td>The readHeaderData API will find the StrongridIEEEC37118Client object using the pseudoPdcId and gets the Header frame from the associated PDC/PMU. From the Header Frame it will get all the Header values.On success this API will return 0.On failure this API will return 1.</td></tr>
<tr><td>int   <strong>readConfiguration</strong> ( int32_t timeOutMs int32_t pseudoPdcId)</td><td>The readConfiguration API will find the StrongridIEEEC37118Client object using the pseudoPdcId and gets the Configuration 2 frame based on the version of the associated PDC/PMU. From the Configuration 2 Frame it will get all the Configuration values.On success this API will return 0.On failure this API will return 1.</td></tr>
<tr><td>int   <strong>readConfiguration_Ver3</strong> ( int32_t timeOutMs int32_t pseudoPdcId)</td><td>The readConfiguration_Ver3API will find the StrongridIEEEC37118Client object using the pseudoPdcId and gets the Configuration 3 frame based on the version of the associated PDC/PMU. From the Configuration 3 Frame it will get all the Configuration values (note that the optional CFG-3 is introduced with version 2 of the protocol - IEEE Std C37.118.2-2011).On success this API will return 0.On failure this API will return 1.</td></tr>
<tr><td>int <strong>getHeaderMsg</strong> (char* msg, int maxMsgLength, int32_t pseudoPdcId)</td><td>The getHeaderMsg API will find StrongridIEEEC37118Client object using the pseudoPdcId and send the header information.On success this API will return 0On failure this API will return 1</td></tr>
<tr><td>int <strong>getPdcConfig</strong> (pdcConfiguration* pdcCfg,int32_t pseudoPdcId)</td><td>The getPdcConfig API will finds the StrongridIEEEC37118Client object using the pseudoPdcId and send theconfiguration 2 frame details.On success this API will return 0On failure this API will return 1</td></tr>
<tr><td>int <strong>getPdcConfig_Ver3</strong> (pdcConfiguration* pdcCfg,int32_t pseudoPdcId)</td><td>The getPdcConfig_Ver3 API will finds the StrongridIEEEC37118Client object using the pseudoPdcId and send theconfiguration 3 frame details (note that the optional CFG-3 is introduced with version 2 of the protocol - IEEE Std C37.118.2-2011).On success this API will return 0On failure this API will return 1</td></tr>
<tr><td>int <strong>getPmuConfiguration</strong> (pmuConfig* pmuconf,int32_t pseudoPdcId, int32_t pmuIndex)</td><td>The getPmuConfiguration  API will find particular PMU related to the pseudoPdcId and pmuIndex given and sends all the configuration 2 frame details related to current PMU.On success this API will return 0On failure this API will return 1</td></tr>
<tr><td>int <strong>getPmuConfiguration_Ver3</strong> (pmuConfig_Ver3* pmuconf,int32_t pseudoPdcId, int32_t pmuIndex)</td><td>The getPmuConfiguration_Ver3 API will find particular PMU related to the pseudoPdcId and pmuIndex given and sends all the configuration 3 frame details related to current PMU (note that the optional CFG-3 is introduced with version 2 of the protocol - IEEE Std C37.118.2-2011).On success this API will return 0On failure this API will return 1</td></tr>
<tr><td>int   <strong>getPhasorConfig</strong> ( phasorConfig *phasorCfg,int32_t pseudoPdcId,int32_t pmuIndex,int32_t phasorIndex)</td><td>The getPhasorConfig API will find the StrongridIEEEC37118Client object using the pseudoPdcId and gets the Configuration 2 frame phasor configuration of the associated PDC/PMU. From the Configuration Frame it will get the configuration of the PMU using the pmuIndex, and by using the phasorIndex it will get the particular phasorConfig.On success this API will return 0 On failure this API will return 1.</td></tr>
<tr><td>int   <strong>getPhasorConfig_Ver3</strong> ( phasorConfig_Ver3 *phasorCfg, int32_t pseudoPdcId,int32_t pmuIndex,int32_t phasorIndex)</td><td>The getPhasorConfig_Ver3API will find the StrongridIEEEC37118Client object using the pseudoPdcId and gets the Configuration 3 frame phasor configuration of the associated PDC/PMU. From the Configuration Frame it will get the configuration of the PMU using the pmuIndex, and by using the phasorIndex it will get the particular phasorConfig.On success this API will return 0 On failure this API will return 1.</td></tr>
<tr><td>int   <strong>getAnalogConfig</strong> ( analogConfig *analogCfg,int32_t pseudoPdcId,int32_t pmuIndex,int32_t analogIndex)</td><td>The getAnalogConfig API will find the StrongridIEEEC37118Client object using the pseudoPdcId and gets the Configuration 2 frame analog value configuration of the associated PDC/PMU. From the Configuration Frame it will get the configuration of the PMU using the pmuIndex, and by using the analogIndex it will get the particular analogConfig.On success this API will return 0 On failure this API will return 1.</td></tr>
<tr><td>int   <strong>getAnalogConfig_Ver3</strong> ( analogConfig_Ver3 *analogCfg,int32_t pseudoPdcId,int32_t pmuIndex,int32_t analogIndex)</td><td>The getAnalogConfig API will find the StrongridIEEEC37118Client object using the pseudoPdcId and gets the Configuration 3 frame analog value configuration of the associated PDC/PMU. From the Configuration Frame it will get the configuration of the PMU using the pmuIndex, and by using the analogIndex it will get the particular analogConfig.On success this API will return 0 On failure this API will return 1.</td></tr>
<tr><td>int   <strong>getDigitalConfig</strong> ( digitalConfig* digitalCfg, int32_t pseudoPdcId,int32_t pmuIndex,int32_t digitalIndex)</td><td>The getDigitalConfig API will find the StrongridIEEEC37118Client object using the pseudoPdcId and gets the Configuration 2 frame digital value configuration of the associated PDC/PMU. From the Configuration Frame it will get the configuration of the PMU using the pmuIndex, and by using the digitalIndex it will get the particular digitalConfig.On success this API will return 0 .On failure this API will return 1.</td></tr>
<tr><td>int   <strong>getDigitalConfig_Ver3</strong> ( digitalConfig* digitalCfg, int32_t pseudoPdcId,int32_t pmuIndex,int32_t digitalIndex)</td><td>The getDigitalConfig_Ver3 API will find the StrongridIEEEC37118Client object using the pseudoPdcId and gets the Configuration 3 frame digital value configuration of the associated PDC/PMU. From the Configuration Frame it will get the configuration of the PMU using the pmuIndex, and by using the digitalIndex it will get the particular digitalConfig.On success this API will return 0 .On failure this API will return 1.</td></tr>
<tr><td>int   <strong>startDataStream</strong> (int32_t pseudoPdcId)</td><td>The startDataStream API will find the StrongridIEEEC37118Client object using the pseudoPdcId and send the START_DATA_FRAME command to the associated PMU/PDC. On success this API will return 0On failure this API will return 1.</td></tr>
<tr><td>Int <strong>pollPdcWithDataWaiting</strong> ( int pseudoPdcIdArrayLength, int32_t* outPseudoPdcIdArr, int32_t* outNumPdcWithData, int pollTimeoutMs)</td><td>The startDataStream API will fill a list over PMU/PDCs which have available data frames to read. The function fills Fills in &quot;outPseudoPdcIdArr&quot; with pseudoPdcId's which have data waiting. Note that call to the readNextFrame() function with pseudoPdcId related to PMU/PDC with available data frames to read will not lead to blocking of the thread the function is called from. Note also that the return list with PMU/PDCs which have available data frames to read can only contain any of the PseudoPdcId numbers related to PMU/PDCs currently connected to the  Strongrid IEEE C37.118 DLL.pseudoPdcIdArrayLength = The length of the input array outPseudoPdcIdArr = the input array where the pseudo PDC id's are placedoutNumPdcWithData = the total number of PDC's with data waitingOn success this API will return 0On failure this API will return 1</td></tr>
<tr><td>int <strong>readNextFrame</strong> (int32_t timeoutMs, int32_t pseudoPdcId)</td><td>Reads the next data frame from the PDC/PMU associated with using the pseudoPdcId.On success this API will return 0.On failure this API will return 1.</td></tr>
<tr><td>Int <strong>getPdcRealData</strong> (pdcDataFrame* rd,int32_t pseudoPdcId)</td><td>This API will find particular PDC using pseudoPdcId and sends all the Real time data from the associated PDC.On success this API will return 0On failure this API will return 1</td></tr>
<tr><td>Int <strong>getPmuRealData</strong> (pmuDataFrame* rd,PmuStatus* status,int32_t pseudoPdcId,int32_t pmuIndex)</td><td>This API will find particular PMU using pseudoPdcId and sends all the Real time data from the associated PMU/PDC.On success this API will return 0On failure this API will return 1</td></tr>
<tr><td>int   <strong>stopDataStream</strong> (int32_t pseudoPdcId)</td><td>The stopDataStream API will find the StrongridIEEEC37118Client object using the pseudoPdcId and send the STOP_DATA_FRAME command to the associated PMU/PDC On success this API will return 0On failure this API will return 1</td></tr>
<tr><td>int   <strong>disconnectPdc</strong> (int32_t pseudoPdcId)</td><td>The disconnectPdc API will find the StrongridIEEEC37118Client object using the pseudoPdcId and closes the connection and free the StrongridIEEEC37118Client object.On success this API will return 0On failure this API will return 1</td></tr>
<tr><td>int <strong>dllshutdown</strong> ()</td><td>The int dllshutdown API shut down the Strongrid IEEE C37.118 DLL.</td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="labview-compatability-functions"></a><a href="#labview-compatability-functions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Labview compatability functions</h3>
<p>Note that all char* arrays must be 256 bytes, or longer</p>
<table>
<thead>
<tr><th><strong>Method</strong></th><th><strong>Description</strong></th></tr>
</thead>
<tbody>
<tr><td>Int <strong>getPmuConfigurationLabview</strong> (noArraysPmuConfig* pmuconf, char* stationName,int32_t pseudoPdcId,int32_t pmuIndex)</td><td>The getPmuConfigurationLabview API will find particular PMU related to the pseudoPdcId and pmuIndex given and sends all the configuration 2 frame details related to current PMU.Note ! Only used together with LabView application.On success this API will return 0On failure this API will return 1</td></tr>
<tr><td>Int <strong>getPhasorConfigLabview</strong> (noArraysPhasorConfig *phasorCfg,char* name,int32_t pseudoPdcId,int32_t pmuIndex,int32_t phasorIndex)</td><td>The getPhasorConfigLabview API will find the StrongridIEEEC37118Client object using the pseudoPdcId and gets the Configuration 2 frame phasor configuration of the associated PDC/PMU. From the Configuration Frame it will get the configuration of the PMU using the pmuIndex, and by using the phasorIndex it will get the particular phasorConfig.Note ! Only used together with LabView application.On success this API will return 0 On failure this API will return 1.</td></tr>
<tr><td>Int <strong>getAnalogConfigLabview</strong> (noArraysAnalogConfig *analogCfg,char* name,int32_t pseudoPdcId,int32_t pmuIndex,int32_t analogIndex)</td><td>The getAnalogConfigLabview API will find the StrongridIEEEC37118Client object using the pseudoPdcId and gets the Configuration 2 frame analog value configuration of the associated PDC/PMU. From the Configuration Frame it will get the configuration of the PMU using the pmuIndex, and by using the analogIndex it will get the particular analogConfig.Note ! Only used together with LabView application.On success this API will return 0 On failure this API will return 1.</td></tr>
<tr><td>Int <strong>getDigitalConfigLabview</strong> (noArraysDigitalConfig* digitalCfg,char* name,int32_t pseudoPdcId,int32_t pmuIndex,int32_t digitalIndex)</td><td>The getDigitalConfigLabview API will find the StrongridIEEEC37118Client object using the pseudoPdcId and gets the Configuration 2 frame digital value configuration of the associated PDC/PMU. From the Configuration Frame it will get the configuration of the PMU using the pmuIndex, and by using the digitalIndex it will get the particular digitalConfig.Note ! Only used together with LabView application.On success this API will return 0 .On failure this API will return 1.</td></tr>
<tr><td>Int <strong>getPmuRealDataLabview</strong> (noArraysPmuDataFrame* rd, PmuStatus* status,uint16_t PhasorArrayLength, float* phasorValueReal, float* phasorValueImaginary,uint16_t AnalogArrayLength, float* analogValueArruint16_t DigitalArrayLength,uint8_t* digitalValueArr,int32_t pseudoPdcId,int32_t pmuIndex)</td><td>This API will find particular PMU using pseudoPdcId and sends all the Real time data from the associated PMU/PDC. Note ! Only used together with LabView application.On success this API will return 0On failure this API will return 1</td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="strongrid-ieee-c37118-dll-type-definitions-and-data-structures"></a><a href="#strongrid-ieee-c37118-dll-type-definitions-and-data-structures" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Strongrid IEEE C37.118 DLL type definitions and data structures</h2>
<table>
<thead>
<tr><th><strong>Type definition</strong></th><th><strong>Description</strong></th></tr>
</thead>
<tbody>
<tr><td>typedef signedchar        int8_t;typedef short                 int16_t;typedef int                int32_t;typedef long long         int64_t;typedef unsigned char        uint8_t;typedef unsigned short         uint16_t;typedef unsigned int         uint32_t;typedef unsigned long long uint64_t;</td><td>Type definitions used in Strongrid IEEE C37.118 DLL.</td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th><strong>Data structure</strong></th><th><strong>Description</strong></th></tr>
</thead>
<tbody>
<tr><td>typedef struct { int32_t LeapSecCorrection;         bool LeapSecPending;         bool ClockIsReliable;        float ClockErrorSec;} TimeStatus</td><td>The TimeStatus data structure contains variables related to the quality of the data frame time stamp.  +1 for 1 second added, and -1 for subtract. 0 means no changeEarly warning of pending leap second</td></tr>
<tr><td>typedef struct {        int16_t Year;        int16_t Month;        int16_t Day;        int16_t Hour;        int16_t Minute;        int16_t Second;        int16_t Ms;} ParsedTimestamp;</td><td>The ParsedTimestamp data structure contains variables related to the data frame time stamp.</td></tr>
<tr><td>typedef struct {        TimeStatus TimeQuality;        ParsedTimestamp Timestamp;        double SecondOfCentury;        float FramesPerSecond;        int numberOfPMUs;}pdcConfiguration;</td><td>The pdcConfiguration data structure contains variables related to the PDC configuration.</td></tr>
<tr><td>typedef struct{                int32_t pmuid;        char* stationname;        float nominalFrequency;        int32_t numberOfPhasors;        int32_t numberOfAnalog;        int32_t numberOfDigital;}pmuConfig;</td><td>The pdcConfiguration data structure contains variables related to the PMU configuration received in CFG-2 configuration frames, which are part of the IEEE Std C37.118-2005 protocol.</td></tr>
<tr><td>typedef struct{                int32_t pmuid;        float nominalFrequency;        int32_t numberOfPhasors;        int32_t numberOfAnalog;        int32_t numberOfDigital;}noArraysPmuConfig;</td><td>The noArraysPmuConfig data structure contains variables related to the PMU configuration received in CFG-2 configuration frames, which are part of the IEEE Std C37.118-2005 protocol.</td></tr>
<tr><td>typedef struct{                int32_t pmuid;        char* stationname;        float nominalFrequency;        int32_t numberOfPhasors;        int32_t numberOfAnalog;        int32_t numberOfDigital;        float POS_LAT;        float POS_LON;        float POS_ELEV;        uint8_t SVC_CLASS;        int32_t PhasorMeasurementWindow;        int32_t PhasorMeasurementGroupDelayMs;        char globalPmuId[16];}pmuConfig_Ver3;</td><td>The pdcConfiguration data structure contains variables related to the PMU configuration received in CFG-3 configuration frames, which are part of the IEEE Std C37.118-2011 protocol.</td></tr>
<tr><td>typedef struct PmuStatus{        uint8_t dataErrorCode;            bool pmuSyncFlag;        bool pmuDataSortingFlag;        bool pmuTriggerFlag;        bool configChangeFlag;        bool dataModifiedFlag;        uint8_t timeQualityCode;        uint8_t unlockTimeCode;            uint8_t triggerReasonCode;        };</td><td>The PmuStatus data structure contains quality variables related to the received data frames.  Data error:        - 0 = good measurement data - no errors        - 1 = PMU error. No information about data        - 2 = PMU in test mode         - 3 = PMU error (no not use values) PMU in sync with a UTC tracable time source Data sorting - true=sort by timestamp / false=sort by arrival PMU trigger detected  Configuration change detected Data modified - true=modified by post processing / false=not PMU time quality (TODO) Unlocked time:        - 0 = sync locked or unlocked &lt; 10 s (best quality)        - 1 = 10 s &lt;= unlocked time &lt; 100 s        - 2 = 100s &lt; unlock time &lt;= 1000s        - 3 = unlocked time &gt; 1000s Trigger reason        - 0 = manual        - 1 = magnitude low        - 2 = magnitude high        - 3 = Phase angle diff        - 4 = Frequency high or low        - 5 = df/dt High        - 6 = &lt;reserved&gt;        - 7 = Digital</td></tr>
<tr><td>typedef struct {                TimeStatus TimeQuality;        ParsedTimestamp Timestamp;        double SecondOfCentury;        int NumPmuInDataFrame;}pdcDataFrame ;</td><td>The pdcDataFrame data structure contains variables related to the PDC part of received data frames.</td></tr>
<tr><td>typedef struct {                PmuStatus        status;        float                frequency;        float                deltaFrequency;        uint16_t                PhasorArrayLength;        float*                phasorValueReal;        float*                phasorValueImaginary;        uint16_t                AnalogArrayLength;        float*                analogValueArr;        uint16_t                DigitalArrayLength;        bool*                digitalValueArr;}pmuDataFrame ;</td><td>The pmuDataFrame data structure contains variables related to the PMU part of received data frames.</td></tr>
<tr><td>typedef struct {        char*                name;          uint8_t                type;         uint8_t                format;        bool                dataIsScaled;        float                scalar;}phasorConfig;</td><td>The phasorConfig data structure contains variables related to the phasor configuration received in CFG-2 configuration frames, which are part of the IEEE Std C37.118-2005 protocol. INPUT ARRAY MUST BE &gt;= 256 in length 0 == voltage, 1 == current 0 = rectangular, 1 = polar,  NOTE: currently this version is always in 'rectangular' True if scaled - false if not</td></tr>
<tr><td>typedef struct {char* name;          uint8_t                type;         uint8_t                format;         bool                dataIsScaled;                float                scaling_magnitude;        float                scaling_angleOffset;}phasorConfig_Ver3;</td><td>The phasorConfig_Ver3 data structure contains variables related to the phasor configuration received in CFG-3 configuration frames, which are part of the IEEE Std C37.118-2011 protocol. INPUT ARRAY MUST BE &gt;= 256 in length 0 == voltage, 1 == current        0 = rectangular, 1 = polar, NOTE: currently this version is always in 'rectangular' True if scaled - false if not</td></tr>
<tr><td>typedef struct {                char*                name;        int Type;             bool                dataIsScaled;          float                userdefined_scalar;}analogConfig;</td><td>The analogConfig data structure contains variables related to the analog value configuration received in CFG-2 configuration frames, which are part of the IEEE Std C37.118-2005 protocol.INPUT ARRAY MUST BE &gt;= 256 in lengthType of analog value measurement :        0 = Single point on wave        1 = RMS of analog input        2 = peak of analog input        5-64 = reserved Scaling information : True if already scaled - false if not</td></tr>
<tr><td>typedef struct {                char*                name;          bool                dataIsScaled;          float                scaling_magnitude;        float                scaling_offset;}analogConfig_Ver3;</td><td>The analogConfig data structure contains variables related to the analog value configuration received in CFG-3 configuration frames, which are part of the IEEE Std C37.118-2011 protocol.INPUT ARRAY MUST BE &gt;= 256 in length         Scaling information : True if already scaled - false if not</td></tr>
<tr><td>typedef struct {        char*                name;        bool                normalBit;         bool  isValidBit;  }digitalConfig;</td><td>The analogConfig data structure contains variables related to the analog value configuration received in CFG-3 configuration frames, which are part of the IEEE Std C37.118-2011 protocol.INPUT ARRAY MUST BE &gt;= 256 in length         &quot;Normal&quot; state of bit Bit is valid</td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="flow-charts"></a><a href="#flow-charts" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Flow charts</h2>
<h3><a class="anchor" aria-hidden="true" id="representing-one-thread-per-pmu-pdc"></a><a href="#representing-one-thread-per-pmu-pdc" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Representing one thread per PMU/PDC</h3>
<p><img src="/docs/img/Flowchart-1.png" alt="Flowchart 1"></p>
<h3><a class="anchor" aria-hidden="true" id="representing-the-thread-pool-with-read-queue"></a><a href="#representing-the-thread-pool-with-read-queue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Representing the thread pool with read Queue</h3>
<p><img src="/docs/img/Flowchart-2.png" alt="Flowchart 1"></p>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#introduction">INTRODUCTION</a><ul class="toc-headings"><li><a href="#document-scope">Document scope</a></li><li><a href="#strongrid-ieee-c37118-dll-interface-overview">Strongrid IEEE C37.118 DLL Interface overview</a></li><li><a href="#usage-of-methods">Usage of methods</a></li><li><a href="#one-thread-per-pmu-pdc">One thread per PMU/PDC</a></li><li><a href="#threadpool-with-readqueue">Threadpool with readqueue</a></li><li><a href="#conclusions">Conclusions</a></li></ul></li><li><a href="#strongrid-ieee-c37118-dll-apis">Strongrid IEEE C37.118 DLL APIs</a><ul class="toc-headings"><li><a href="#general-functions">General functions</a></li><li><a href="#labview-compatability-functions">Labview compatability functions</a></li></ul></li><li><a href="#strongrid-ieee-c37118-dll-type-definitions-and-data-structures">Strongrid IEEE C37.118 DLL type definitions and data structures</a></li><li><a href="#flow-charts">Flow charts</a><ul class="toc-headings"><li><a href="#representing-one-thread-per-pmu-pdc">Representing one thread per PMU/PDC</a></li><li><a href="#representing-the-thread-pool-with-read-queue">Representing the thread pool with read Queue</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/S3DK/" class="nav-home"><img src="/S3DK/img/ALSET_RPI.png" alt="Documentation" width="100" height="30"/></a><div><h5>Specific Github links</h5><a href="https://github.com/ALSETLab/S3DK-STRONGgrid">S3DK-STRONGgrid</a><a href="https://github.com/ALSETLab/S3DK">S3DK</a></div><div><h5>Links to stuff</h5><a href="https://google.com">Literally Google</a><a href="https://en.wikipedia.org/wiki/Phasor_measurement_unit" target="_blank" rel="noreferrer noopener">Basic Info for PMU</a><a href="https://www.rpi.edu/">Rensselaer Polytechnic Institute</a><a href="https://alsetlab.github.io/" target="_blank" rel="noreferrer noopener">Alset Lab</a></div><div><h5>Docusaurus Resources</h5><a href="https://docusaurus.io/en/">Docusarus website</a><a href="https://github.com/facebook/docusaurus">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/S3DK/img/fb.jpg" alt="Facebook Open Source" width="50" height="45"/></a><section class="copyright">Copyright © 2018 Rensselaer Polytechnic Institute</section></footer></div></body></html>